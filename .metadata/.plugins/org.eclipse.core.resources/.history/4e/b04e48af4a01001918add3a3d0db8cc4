
/* Includes */
#include "stm32f4xx.h"
#include "GPIO_Driver.h"


/* Private macro */
/* Private variables */
/* Private function prototypes */
/* Private functions */

/**
**===========================================================================
**
**  	GPIO Driver
**
**===========================================================================
*/

// RCC->AHB1ENR |= 0x0F;
// RCC->AHB1ENR |= 0b1111;
// RCC->AHB1ENR |=0b01111;    same as before!
//enable port a to port d.

// set pin 5 of port a high.  -- SETTING --
//GPIOA->BSRR = 0b100000;
//GPIOA->BSRR = 1<<5;

//set pin 5 and pin 0 as high
//GPIOA->BSRR = 0b100001;

int Ticks = 0;
void TIM4_IRQHandler();
//void delay_uS(uint32_t uS);
void delay_mS(uint32_t mS);

int main(void)
{


	FLASH->ACR  = FLASH_ACR_ACC64;   // 64-bit access
	FLASH->ACR |= FLASH_ACR_LATENCY; // one wait state
	FLASH->ACR |= FLASH_ACR_PRFTEN;  // prefetch enable


	RCC->CFGR  |= RCC_CFGR_SW_PLL;
	RCC->CFGR  |=RCC_CFGR_SWS_PLL;
	RCC->CFGR  |=RCC_CFGR_PPRE1_DIV2;






	RCC->CR |= RCC_CR_PLLON;
	RCC->CR |= RCC_CR_PLLRDY;


 GPIO_TYPE myGPIO;
myGPIO.port = PORTA;
myGPIO.mode = OUTPUT_MODE;
myGPIO.speed = SPEED_V_HIGH;
myGPIO.mode_type = OUTPUT_PUP;
gpio_port_config(myGPIO,(int []) {5},1);

//gpio_port_clear(PORTA,0b111);

gpio_interrupt_configure(PORTC,13,FALLING_EDGE);
gpio_interrupt_enable(13,EXTI15_10_IRQn);


//myGPIO.port = PORTC;
//myGPIO.mode = INPUT_MODE;
//gpio_port_config(myGPIO,(int []) {13});


RCC->APB1ENR |= RCC_APB1ENR_TIM4EN;
TIM4->PSC = 96;
TIM4->ARR = 1000;
TIM4->CR1 &= ~TIM_CR1_DIR; //Up counter. By default, but still good practice
//TIM4->CR1 |= TIM_CR1_URS; // Only up/down counter generates an update interrupt // good practice
TIM4->DIER = TIM_DIER_UIE; // Update interrupt enabled
NVIC_EnableIRQ(TIM4_IRQn);

//TIM4->EGR = TIM_EGR_UG; //simulating an interrupt





for (int i = 0; i<500; i++) {
delay_mS(3000);  //comment out if u want to use B2 delay
gpio_write(PORTA,5,1);
}





/*for (int i=0; i<10; i++)
{
	gpio_write(PORTA,5,0);
	for(int i=0; i<500000; i++);
	gpio_write(PORTA,5,1);
	for(int i=0; i<500000; i++);
}


*/
}


void EXTI15_10_IRQHandler() //At the moment, it doesn't differentiate between line EXTI15 TO EXTI10. Need to add more code below to do that.
{
	gpio_interrupt_clear(13);
	gpio_write(PORTA,5,0);

	for (int i = 0; i<20; i++)
	{
			//gpio_write(PORTA,5,1);
			//for(int i=0; i<100000; i++); // wait some time. Basically a delay
			gpio_write(PORTA,5,0);
			for(int i=0; i<100000; i++); //
	}

}



void TIM4_IRQHandler()
{

	Ticks++;
	TIM4->SR &= ~TIM_SR_UIF; // cleared update interrupt

}


void delay_mS(uint32_t mS)
{
		TIM4->CR1 |= TIM_CR1_CEN;
		Ticks = 0;

		while(Ticks<mS);

		TIM4->CR1 &= ~TIM_CR1_CEN;

}




































//gpio_enable_interrupt(13,EXT13_IRQn);

//gpio_port_set();
//gpio_port_clear();
//gpio_port_config();


//GPIOA->BSRR = 0b100001;
//gpio_port_set(PORTA,0xFFFF);
//gpio_port_clear(PORTA,0x0f);

/* myGPIO.port = PORTA;
myGPIO.pin = 5;
myGPIO.mode = OUTPUT_MODE;
gpio_init(myGPIO);

while(1){
gpio_write(PORTA,5,1);
for(int i=0; i<500000; i++);
gpio_write(PORTA,5,0);
for(int i=0; i<500000; i++);
}



*/


