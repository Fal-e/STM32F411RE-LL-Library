/*
 * ss_delay.c
 *
 *  Created on: 4May,2019
 *      Author: Falcon
 */

#include <stdint.h>
#include "ss_delay.h"
#include "stm32f10x.h"
#include "stm32f10x_rcc.h"








void config_clock_72MHz(void)

{
	// Set PLL multiplication factor to 9.




	// Select HSE as PLL source
	RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_PLLSRC) | RCC_CFGR_PLLSRC_HSE;

	// External Freq undivided
	RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_PLLXTPRE) | RCC_CFGR_PLLXTPRE_HSE;



	RCC->CR |= RCC_CR_HSEON;
	while(!(RCC_CR_HSERDY));

	//RCC->CFGR &= ~(1<<1);
	//RCC->CFGR |= RCC_CFGR_SW_HSE;
	//while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSE)


	//RCC->CFGR |= RCC_CFGR_SW_PLL; // Select PLL as SYSCLK
	//while(!(RCC->CFGR & RCC_CFGR_SWS_PLL)); // Wait for PLL to be ready




	FLASH->ACR |= FLASH_ACR_PRFTBE; // Prefetch Buffer enable
		FLASH->ACR |= FLASH_ACR_LATENCY_2; // Two wait states since 48 MHz < SYSCLK <= 72 MHz
		while(!(FLASH->ACR & FLASH_ACR_PRFTBS)); // Wait until prefetch buffer enabled (Reading ACR register)


	// Enable PLL oscillator
	RCC->CR = (RCC->CR) && ~RCC_CR_PLLON;
	RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_PLLMULL) | RCC_CFGR_PLLMULL9;
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));


	RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_SW) | RCC_CFGR_SW_PLL;



	uint8_t test = RCC_GetSYSCLKSource();

	//RCC->CFGR |= RCC_CFGR_PLLSRC_HSE;
	//RCC->CR &= ~RCC_CR_HSION;
	//RCC->CFGR |= RCC_CFGR_PLLMULL9; // x9 baybayyyy
	//RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;
	//RCC->CR |= RCC_CR_PLLON;




	/* Select PLL as system Clock */
	//RCC->CFGR &= ~RCC_CFGR_SW;            /* Clear */
	//RCC->CFGR |=  RCC_CFGR_SW_PLL;    /* Set   */

	/* Wait for PLL to become system core clock */
	//while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);

}


void config_clock_50MHz(void)
{
	/* Enable HSI */
	RCC->CR |= ((uint32_t)RCC_CR_HSION);

	/* Wait for HSI to be ready */
	while ((RCC->CR & RCC_CR_HSIRDY) == 0){
	  // Nop
	}

	/* Set HSI as the System Clock */
	RCC->CFGR |= (RCC->CFGR && ~RCC_CFGR_SW) | RCC_CFGR_SW_HSI;

	/* Wait for HSI to be used for the system clock */
	while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI){
	 // Nop
	}

	// some shit here //
	FLASH->ACR |= FLASH_ACR_PRFTBE;                          // Enable Prefetch Buffer
	FLASH->ACR |= FLASH_ACR_LATENCY_2;                         // Flash 1 wait state

	RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_PLLMULL) | RCC_CFGR_PLLMULL9;

	// HCLK is now 50 MHz



	// the commented out apb1 apb2 means not divided.

	/* Enable PLL */
	 RCC->CR &= ~RCC_CR_PLLON;       /* Disable PLL */
	 RCC->CR |= RCC_CR_PLLON;        /* Enable PLL     */

	   /* Wait until the PLL is ready */
	 while((RCC->CR & RCC_CR_PLLRDY) == 0){
	       //Nop
	   }

	   /* Select PLL as system Clock */
	 RCC->CFGR &= ~RCC_CFGR_SW;            /* Clear */
	 RCC->CFGR |=  RCC_CFGR_SW_PLL;    /* Set   */

	   /* Wait for PLL to become system core clock */
	 while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL){
	       //Nop
	   }

}


RCC_ClocksTypeDef ClksFreq;

void SysClkSetHSI_4xPLLMul (uint32_t PLLMul ) {
      if (PLLMul > RCC_PLLMul_12) {
            FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
            // Flash 2 wait state for freq > 4x12 48MHz
            FLASH_SetLatency(FLASH_Latency_2);
      }
      else if (PLLMul > RCC_PLLMul_6) {
            FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
            // Flash 1 wait state for freq > 4x6 24MHz
            FLASH_SetLatency(FLASH_Latency_1);
      }
      // PLL provides frequency multiplier of (HSI/2) i.e. 4MHz x ...
      RCC_PLLConfig(RCC_PLLSource_HSI_Div2, PLLMul);
      // Enable PLL
      RCC_PLLCmd(ENABLE);
      // Wait till PLL is ready
      while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
      // Select PLL as system clock source
      RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
      // Wait till PLL is used as system clock source
      while (RCC_GetSYSCLKSource() != 0x08);
      // AHB, AP2 and AP1 clock are necessary for the peripherals to function
      // HCLK for AHB = SYSCLK (max is SYSCLK, up to 72MHz)
      RCC_HCLKConfig(RCC_SYSCLK_Div1);
      // PCLK2 for APB2 = HCLK (max is SYSCLK, up to 72MHz)
      RCC_PCLK2Config(RCC_HCLK_Div1);
      if (PLLMul > RCC_PLLMul_9) {
            // PCLK1 for APB1 = HCLK/2 (> 4x9MHz max of 36MHz, use slower clock)
            RCC_PCLK1Config(RCC_HCLK_Div2);
      }
      else {
            // PCLK1 for APB1 = HCLK (HCLK <= 36MHz)
            RCC_PCLK1Config(RCC_HCLK_Div1);
      }
      RCC_GetClocksFreq(&ClksFreq); // update SYSCLK, HCLK, PCLK1 and PCLK2 in ClksFreq
}




