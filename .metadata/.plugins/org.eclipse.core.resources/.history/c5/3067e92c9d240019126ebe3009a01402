
/* Includes */
#include "stm32f4xx.h"
#include "GPIO_Driver.h"
#include "Timer_Delay.h"
//#include "lcd_8bit.h"
#include "lcd_4bit.h"
#include "I2C_Library.h"

/* Private macro */
/* Private variables */
/* Private function prototypes */
/* Private functions */

/**
**===========================================================================
**
**  	GPIO Driver
**
**===========================================================================
*/



int main(void)
{

/*config_clock_50MHz(); // Configuring the delays, as well as setting the clk freq
lcd_init();
lcd_goto_xy(2,1);
lcd_print("Suad");
lcd_goto_xy(4,2);
lcd_print("Shahini");
//delay_mS(2000);
*/

config_clock_50MHz();


GPIO_TYPE myGPIO;
myGPIO.port = PORTA;
myGPIO.mode = OUTPUT_MODE;
myGPIO.mode_type = OUTPUT_PUP;
gpio_port_config(myGPIO,(int []) {5},1);


I2C_enable();


// D7 D6 D5 D4 X  EN RW RS
// P7 P6 P5 P4 P3 P2 P1 P0


// Send upper nibble
// Start bit
// Address
//	0  1  1	 1	X  0  0	 0  <- data UPPER NIBBLE
// 	0  1  1	 1	X  1  0	 0  <- data HIGH ENABLE
// Stop bit

//  5 ms delay		HIGH TO LOW PULSE ON ENABLE


// start
// address
// 0  1  1	 1	X  0  0	 0  <- data LOW ENABLE
// stop bit
//

/********* 0x33 ********/
// Upper nibble
I2C_start();
I2C_addressWrite(0x27);
int test=I2C_data(0x3<<4 | 0b000);
I2C_data(0x3<<4 | 0b100);
I2C_stop();
delay_mS(5);

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x3<<4 | 0b000);
I2C_stop();
delay_mS(5);

// Lower nibble
I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x3<<4 | 0b000);
I2C_data(0x3<<4 | 0b100);
I2C_stop();
delay_mS(5);

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x3<<4 | 0b000);
I2C_stop();
delay_mS(5);

/********* 0x32 ********/

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x3<<4 | 0b000);
I2C_data(0x3<<4 | 0b100);
I2C_stop();
delay_mS(5);

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x3<<4 | 0b000);
I2C_stop();
delay_mS(5);

// Lower nibble
I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x2<<4 | 0b000);
I2C_data(0x2<<4 | 0b100);
I2C_stop();
delay_mS(5);

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x2<<4 | 0b000);
I2C_stop();
delay_mS(5);

/********* 0x28 ********/

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x2<<4 | 0b000);
I2C_data(0x2<<4 | 0b100);
I2C_stop();
delay_mS(5);

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x2<<4 | 0b000);
I2C_stop();
delay_mS(5);

// Lower nibble
I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x8<<4 | 0b000);
I2C_data(0x8<<4 | 0b100);
I2C_stop();
delay_mS(5);

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x8<<4 | 0b000);
I2C_stop();
delay_mS(5);

/********* 0x0E ********/

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x0<<4 | 0b000);
I2C_data(0x0<<4 | 0b100);
I2C_stop();
delay_mS(5);

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x0<<4 | 0b000);
I2C_stop();
delay_mS(5);

// Lower nibble
I2C_start();
I2C_addressWrite(0x27);
I2C_data(0xE<<4 | 0b000);
I2C_data(0xE<<4 | 0b100);
I2C_stop();
delay_mS(5);

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0xE<<4 | 0b000);
I2C_stop();
delay_mS(5);

/********* 0x01 ********/

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x0<<4 | 0b000);
I2C_data(0x0<<4 | 0b100);
I2C_stop();
delay_mS(5);

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x0<<4 | 0b000);
I2C_stop();
delay_mS(5);

// Lower nibble
I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x1<<4 | 0b000);
I2C_data(0x1<<4 | 0b100);
I2C_stop();
delay_mS(5);

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x1<<4 | 0b000);
I2C_stop();
delay_mS(5);

/********* 0x80 ********/

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x8<<4 | 0b000);
I2C_data(0x8<<4 | 0b100);
I2C_stop();
delay_mS(5);

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x8<<4 | 0b000);
I2C_stop();
delay_mS(5);

// Lower nibble
I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x0<<4 | 0b000);
I2C_data(0x0<<4 | 0b100);
I2C_stop();
delay_mS(5);

I2C_start();
I2C_addressWrite(0x27);
I2C_data(0x0<<4 | 0b000);
I2C_stop();
delay_mS(5);



// Need to add code that checks for acknowledge. If not acknowledged then skip the code below,
// otherwise run it.

//while(!(I2C1->SR1 & I2C_SR1_ADDR)); // Wait for Received Address matched

//while(!(I2C1->SR2 & I2C_SR2_BUSY));






// TODO: Code that handles NACK from slave.
// The program is currently stuck in an infinite loop in the I2C_data command
// Specifically: while(!(I2C1->SR1 & I2C_SR1_TXE));
// This is because when a NACK is received (e.g. wrong address), TXE is not set, therefore remaining in the loop.
// Need to fix this by adding an interrupt, which STOPs or restarts communication.
// Otherwise, will be stuck in loop and no more communication can continue.

//
}














