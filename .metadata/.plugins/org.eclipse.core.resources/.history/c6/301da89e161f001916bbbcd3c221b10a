
/* Includes */
#include "stm32f4xx.h"
#include "GPIO_Driver.h"
#include "Timer_Delay.h"
//#include "lcd_8bit.h"
#include "lcd_4bit.h"
#include "I2C_Library.h"

/* Private macro */
/* Private variables */
/* Private function prototypes */
/* Private functions */

/**
**===========================================================================
**
**  	GPIO Driver
**
**===========================================================================
*/



int main(void)
{

/*config_clock_50MHz(); // Configuring the delays, as well as setting the clk freq
lcd_init();
lcd_goto_xy(2,1);
lcd_print("Suad");
lcd_goto_xy(4,2);
lcd_print("Shahini");
//delay_mS(2000);
*/

config_clock_50MHz();
I2C_enable();


//I2C1->CR2 = I2C_CR2_ITERREN;
//NVIC_EnableIRQ(I2C1_ER_IRQn);


	/* Start */
	//while(I2C1->SR2 & I2C_SR2_BUSY);// Unnecessary
	I2C1->CR1 |= I2C_CR1_START;
	while(!(I2C1->SR1 & I2C_SR1_SB)); // keep waiting until the SB bit has been set


	/* Address Write */
	I2C1->DR = (0x27<<1) & 0b11111110; //lsb is 0 (Reset), therefore master is in transmitter mode
	// EV6
	while(!(I2C1->SR1 & I2C_SR1_ADDR));
	while(!(I2C1->SR2 & I2C_SR2_BUSY));

	/* Data */
	I2C1->DR = 0x33;
	while(!(I2C1->SR1 & I2C_SR1_TXE));

	/* Stop */
	while (!(I2C1->SR1 & I2C_SR1_BTF));
	I2C1->CR1 |= I2C_CR1_STOP;



	delay_mS(10);
	while(I2C1->SR2 & I2C_SR2_BUSY);
	I2C1->CR1 |= I2C_CR1_START;
	while(!(I2C1->SR1 & I2C_SR1_SB)); // keep waiting until the SB bit has been set



	I2C1->DR = (0x27<<1) & 0b11111110; //lsb is 0 (Reset), therefore master is in transmitter mode
	// EV6
	while(!(I2C1->SR1 & I2C_SR1_ADDR));
	while(!(I2C1->SR2 & I2C_SR2_BUSY));


	I2C1->DR = 0x33;
	while(!(I2C1->SR1 & I2C_SR1_TXE));


	while (!(I2C1->SR1 & I2C_SR1_BTF));
	I2C1->CR1 |= I2C_CR1_STOP;


// TODO: Code that handles NACK from slave.
// The program is currently stuck in an infinite loop in the I2C_data command
// Specifically: while(!(I2C1->SR1 & I2C_SR1_TXE));
// This is because when a NACK is received (e.g. wrong address), TXE is not set, therefore remaining in the loop.
// Need to fix this by adding an interrupt, which STOPs or restarts communication.
// Otherwise, will be stuck in loop and no more communication can continue.





//
}

/*
void I2C1_ER_IRQHandler()
{
	I2C1->SR1 = 0x00;
	//I2C1->SR1 &= ~I2C_SR1_AF;
	I2C_stop();
}
*/










