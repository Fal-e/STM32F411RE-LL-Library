/*
 * ss_delay.c
 *
 *  Created on: 4May,2019
 *      Author: Falcon
 */

#include <stdint.h>
#include "ss_delay.h"
#include "stm32f10x.h"
#include "stm32f10x_rcc.h"



int volatile Ticks=0;




void config_clock_72MHz(void)

{
	  // Configure the PLL to (HSI / 2) * 12 = 48MHz.
	  // Use a PLLMUL of 0xA for *12, and keep PLLSRC at 0
	  // to use (HSI / PREDIV) as the core source. HSI = 8MHz.
	  RCC->CFGR  &= ~(RCC_CFGR_PLLMULL |
	                  RCC_CFGR_PLLSRC);
	  RCC->CFGR  |=  (RCC_CFGR_PLLSRC_HSI_Div2 |
	                  RCC_CFGR_PLLMULL12);
	  // Turn the PLL on and wait for it to be ready.
	  RCC->CR    |=  (RCC_CR_PLLON);
	  while (!(RCC->CR & RCC_CR_PLLRDY)) {};
	  // Select the PLL as the system clock source.
	  RCC->CFGR  &= ~(RCC_CFGR_SW);
	  RCC->CFGR  |=  (RCC_CFGR_SW_PLL);
	  while (!(RCC->CFGR & RCC_CFGR_SWS_PLL)) {};
	  // Set the global clock speed variable.

}

void timer_enable(void)
{
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
	TIM2->PSC = 48;
	TIM2->ARR = 1000;
	TIM2->CR1 &= ~TIM_CR1_DIR;

	NVIC_SetPriority(TIM2_IRQn, 0x03);
	NVIC_EnableIRQ(TIM2_IRQn);

}

void TIM2_IRQHandler()
{
	Ticks++;
	TIM2->SR &= ~TIM_SR_UIF; // cleared update interrupt

}

void delay_mS(uint32_t mS)
{
		TIM2->CR1 |= TIM_CR1_CEN;
		Ticks = 0;

		while(Ticks<mS);

		TIM2->CR1 &= ~TIM_CR1_CEN;

}



